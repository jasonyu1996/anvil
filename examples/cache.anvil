type value_4bit =
{
    v : logic[4]
}
type value_2bit =
{
    v : logic[2]
}
type value_3bit =
{
    v : logic[3]
}
type value_8bit =
{
    v : logic[8]
}

type memory_map =
{
    address : logic[8];
    data : logic[8]
}

chan cache_read = {
    left req : (logic[8]@res),
    right res : (logic[8]@req),
    right cache_hit : (logic[2]@req) 
}

chan memory_read = {
    left req : (logic[8]@res),
    right res : (logic[8]@res)
}

chan memory_write = {
    left req : (memory_map@res),
    right res : (logic@res)
}

proc FIFO_Cache(ch : left cache_read, ch_mem : right memory_read) =
    reg cache :value_8bit[4][4]
    reg tag :value_4bit[4][4]
    reg head :value_2bit[4]
    reg tail :value_2bit[4]
    reg count :value_3bit[4]
    reg senddata :logic[8]
    reg cache_hit :logic[2]
    reg head_overflow :logic[1]
    reg valid :logic[4][4]
    loop {
        let address = recv ch::req in
        address => 
        (
                let tag_bits = address[4+:4] in
                (
                    let set_index = address[2+:2] in
                    (
                        if  ((!valid[set_index][0] == 1'b1) & (!tag[set_index][0].v == tag_bits)) then
                        (
                            set senddata := !cache[set_index][0].v;
                            set cache_hit := 2'b01
                        )
                        else
                        (
                            if (!valid[set_index][1] == 1'b1) & (!tag[set_index][1].v == tag_bits) then
                            (
                                set senddata := !cache[set_index][1].v;
                                set cache_hit := 2'b01
                            )
                            else
                            (
                                if (!valid[set_index][2] == 1'b1) & (!tag[set_index][2].v == tag_bits) then
                                (
                                    set senddata := !cache[set_index][2].v;
                                    set cache_hit := 2'b01
                                )
                                else
                                (
                                    if (!valid[set_index][3] == 1'b1) & (!tag[set_index][3].v == tag_bits) then
                                    (
                                        set senddata := !cache[set_index][3].v;
                                        set cache_hit := 2'b01
                                    )
                                    else
                                    (
                                        set cache_hit := 2'b00;
                                        send ch_mem::req(address) =>
                                        let data = recv ch_mem::res in
                                        data =>
                                        (
                                            dprint "Data from memory for address %b: %b" (address, data);
                                            if !count[set_index].v < 3'b100 then
                                            (
                                                (
                                                    let tail_index = !tail[set_index].v in
                                                    (
                                                        set cache[set_index][tail_index].v := data;
                                                        set tag[set_index][tail_index].v := tag_bits;
                                                        set count[set_index].v := !count[set_index].v+3'b001;
                                                        set valid[set_index][tail_index] := 1'b1
                                                    )
                                                )=>
                                                set tail[set_index].v := !tail[set_index].v+2'b01
                                            )
                                            else
                                            (
                                                let head_index = !head[set_index].v in
                                                (
                                                    set cache[set_index][head_index].v := data;
                                                    set tag[set_index][head_index].v := tag_bits;
                                                    set valid[set_index][head_index] := 1'b1;
                                                    if head_index == 2'b11 then
                                                    (
                                                        set head_overflow := 1'b1
                                                    )
                                                    else
                                                    (
                                                        set head_overflow := 1'b0
                                                    )
                                                )=>
                                                if !head_overflow == 1'b0 then
                                                (
                                                    set head[set_index].v := !head[set_index].v+2'b01
                                                )
                                                else
                                                (
                                                    set head[set_index].v := 2'b00
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            
        )=>
        send ch::cache_hit(!cache_hit)=>
        send ch::res(!senddata)
    }


proc Main_Memory(ch : left memory_read, write_ch : left memory_write) =
    reg memory :value_8bit[256]
    loop {
        let address = recv ch::req in
        address =>
        dprint "Memory Read Request for address %b: %b" (address, !memory[address].v);
        send ch::res(!memory[address].v)
    }
    loop
    {
        let x = recv write_ch::req in
        x=>
        (
            dprint "Memory Write Start %b: %b" (x.address, x.data);
            set memory[x.address].v := x.data=>
            send write_ch::res(1'b1)=>
            dprint "Memory says Write Complete %b: %b" (x.address,!memory[x.address].v)
        )
    }


proc cache ()=
    chan cache_input -- cache_output : cache_read
    chan memory_input -- memory_output : memory_read
    chan memory_write_input -- memory_write_output : memory_write
    spawn FIFO_Cache(cache_input, memory_output)
    spawn Main_Memory(memory_input, memory_write_input)
    reg count : logic[4]
    reg address : logic[8]
    reg data : logic[8]
    loop {
    (  
        if !count == 4'b0000 then
        (
            set address := 8'b00000000;
            set data := 8'b01010101;
            set count := !count+4'b0001
        )
        else (
            if !count == 4'b0001 then
            (
                set address := 8'b00010000;
                set data := 8'b10101110;
                set count := !count+4'b0001
            )
            else (
                if !count == 4'b0010 then
                (
                    set address := 8'b00100000;
                    set data := 8'b11011001;
                    set count := !count+4'b0001
                )
                else 
                (
                    if !count == 4'b0011 then
                    (
                        set address := 8'b00110000;
                        set data := 8'b11111111;
                        set count := !count+4'b0001
                    )
        
                    else 
                    (
                        if !count == 4'b0100 then
                        (
                            set address := 8'b00000000;
                            set count := !count+4'b0001
                        )
    
                        else 
                        (
                            if !count == 4'b0101 then
                            (
                                set address := 8'b00010000;
                                set count := !count+4'b0001
                            )
                            else 
                            (
                                if !count == 4'b0110 then
                                (
                                    set address := 8'b00100000;
                                    set count := !count+4'b0001
                                )
                                else 
                                (
                                    if !count == 4'b0111 then
                                    (
                                        set address := 8'b00110000;
                                        set count := !count+4'b0001
                                    )
                                    else
                                    (
                                        set address := 8'b00000000;
                                        set count := 4'b0000
                                    )
                                )
                            )
                        )
                    )
                )
            )
        )
    );
    (
        if !count < 4'b0100 then
        (
            send memory_write_input::req(memory_map::{address=!address; data=!data}) =>
            let y = recv memory_write_output::res in
            y =>
            dprint "Memory Write Complete %b: %b\n\n" (!address, !data);
            cycle 1
        )
        else
        (
            send cache_input::req(!address) =>
            let z = recv cache_output::res in
            z =>
            dprint "Cache (%b) Output: %b" (!address, z)
        )
    )
    }


    loop {
        let x = recv cache_output::cache_hit in
        x =>
        if x == 2'b01 then
            dprint "Cache Hit" ()
        else
            dprint "Cache Miss" ()
    }