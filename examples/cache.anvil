type value_4bit =
{
    v : logic[4]
}
type value_2bit =
{
    v : logic[2]
}
type value_3bit =
{
    v : logic[3]
}
type value_8bit =
{
    v : logic[8]
}

chan cache_read = {
    left req : (logic[8]@res),
    right res : (logic[8]@req),
    right cache_hit : (logic@cache_hit) 
}

chan memory_read = {
    left req : (logic[8]@res),
    right res : (logic[8]@res)
}

chan memory_write = {
    left req : (memory_req@res),
    right res : (memory_res@res)
}

proc FIFO_Cache(ch : left cache_read, ch_mem : right memory_read) =
    reg cache :value_8bit[4][4]
    reg tag :value_4bit[4][4]
    reg head :value_2bit[4]
    reg tail :value_2bit[4]
    reg count :value_3bit[4]
    loop {
        let address = recv ch::req in
        address => 
        (
                let tag_bits = address[4+:4] in
                let set_index = address[2+:2] in
                
                if (!tag[set_index][0].v == tag_bits) then
                (
                    send ch::cache_hit(1'b1);
                    let data = !cache[set_index][0].v in
                    send ch::res(data)
                )

                else 
                (
                    if (!tag[set_index][1].v == tag_bits) then
                    (   
                        send ch::cache_hit(1'b1);
                        let data = !cache[set_index][1].v in
                        send ch::res(data)
                    )
            
                    else 
                    (    
                        if (!tag[set_index][2].v == tag_bits) then
                        (   
                            send ch::cache_hit(1'b1);
                            let data = !cache[set_index][2].v in
                            send ch::res(data)
                        )

                        else
                        ( 
                            if (!tag[set_index][3].v == tag_bits) then
                            (   
                                send ch::cache_hit(1'b1);
                                let data = !cache[set_index][3].v in
                                send ch::res(data)
                            )

                            else
                            ( 
                                send ch::cache_hit(1'b0);
                                send ch_mem::req(address)=>
                                let data = recv ch_mem::res in
                                data => 
                                (
                                    send ch::res(data);
                                    if !count[set_index].v < 3'b100 then
                                    (   
                                        let tail_index = !tail[set_index].v in
                                        (   
                                            set cache[set_index][tail_index].v := data;
                                            set tag[set_index][tail_index].v := tag_bits
                                        )=>
                                        (
                                            set tail[set_index].v:=!tail[set_index].v+2'b01;
                                            set count[set_index].v:=!count[set_index].v+3'b001
                                        )
                                    )

                                    else 
                                    (
                                        let head_index = !head[set_index].v in
                                        (
                                            set cache[set_index][head_index].v:=data;
                                            set tag[set_index][head_index].v:=tag_bits
                                        )=>
                                        (
                                            if !head[set_index].v== 2'b11 then
                                                set head[set_index].v:=2'b00
                                            else
                                                set head[set_index].v:=!head[set_index].v+2'b01
                                        )
                                    )
                                    
                                )
                            )
                        )
                    )
                )
        )
    }
