channel sch{
    left
    {
        bv[8] a<0|->sch?req>;
        bv[8] b<0|->sch?req>;
    }
    right
    {
        bv[8] result<0|->sch!req>;
    }
}

channel ach{
    left
    {
        bv[8] a<0|->ach?req>;
        bv[8] b<0|->ach?req>;  
    }
    right
    {
        bv[8] result<0|->ach!req>;
    }
}

channel ch{
    left::req;
    right::res bv[8] alu_out<0|->ch?res>;
}

proc sub(sch::right)
{  
    recv sch::req(in) =>
        send sch::res(.result(in.a - in.b));
    then

}
proc add(ach::right)
{
    recv ach::req(in) =>
        send ach::res(.result(in.a + in.b));
    then
}

proc simple_cpu(ch::right)
{
    
    reg[8] register_file[2];  // Two 8-bit registers
    reg[3] state;                // State for FSM control
    reg[8] program_counter;      // Program Counter

    // Program Memory 
    reg[8] program_memory[255:0];

    wire[8] instruction<ch?req|->inf> := program_memory[program_counter]
    wire[3] opcode<ch?req|->inf> := instruction[7:5]
    wire reg_dest<ch?req|->inf> := instruction[5]
    wire reg_src<ch?req|->inf> := instruction[6]
    wire[8] immediate<ch?req|->inf> := {4'b0000,instruction[3:0]}

    spawn left::sub sub_inst (sch::sch1)
    spawn left::add add_inst (ach::ach1)
    
        recv ch::req(in);
        program_counter ::= 0;
        register_file[0] ::= 0;
        register_file[1] ::= 0;
        alu_out ::= 0;
        state ::= 0;
        tock =>
            case(state)
                0 : begin
                    state::=1;
                    register_file<0|->ch!res>:=register_file;
                end
                1 : begin
                    case(opcode)
                        3'b000: 
                            wire[8] sub_result;
                            send sch1::req(.a(register_file[reg_dest]),.b(register_file[reg_src]));
                            recv sch1::res(sub_result);
                            alu_out::=sub_result;
                        3'b001:
                            wire[8] add_result;
                            send ach1::req(.a(register_file[reg_dest]),.b(register_file[reg_src]));
                            recv ach1::res(add_result);
                            alu_out::=add_result;
                        3'b010:
                            alu_out ::= register_file[reg_dest] & register_file[reg_src];
                        3'b011:
                            alu_out ::= register_file[reg_dest] | register_file[reg_src];
                        3'b100:
                            alu_out ::= register_file[reg_dest] ^ register_file[reg_src];
                        3'b101:
                            alu_out ::= opcode;
                        3'b110:
                            alu_out ::= immediate;
                        3'b111:
                            alu_out ::= immediate;
                    endcase
                    state ::=2;
                end
                2: begin
                    send ch::res(.alu_out(alu_out));
                    if (opcode > 3'b110) register_file[reg_dest] ::= alu_out;
                    if (opcode < 3'b101) register_file[0] ::= alu_out;
                    state ::=3;
                end
                3: begin
                        program_counter<0|->ch!res> ::= program_counter + 1;
                        state ::= 0;
                end 
            endcase
        then




}